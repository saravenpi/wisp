
#!/usr/bin/env bash

WORK_LOG="$HOME/.wisp.yml"
DEFAULT_DURATION=25
init_work_log() {
    if [ ! -f "$WORK_LOG" ]; then
        cat > "$WORK_LOG" << 'EOF'
sessions:
EOF
    fi
}

get_date() { date +%Y-%m-%d; }
get_time() { date +%H:%M; }
get_timestamp() { date +%s; }

can_send_notifications() {
    if [ "$WISP_NOTIFICATIONS" = "false" ]; then
        return 1
    fi

    if command -v osascript >/dev/null 2>&1; then
        return 0
    elif command -v notify-send >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

send_notification() {
    local title="$1"
    local message="$2"

    if ! can_send_notifications; then
        return 0
    fi

    if command -v osascript >/dev/null 2>&1; then
        osascript -e "display notification \"$message\" with title \"$title\""
    elif command -v notify-send >/dev/null 2>&1; then
        notify-send "$title" "$message"
    fi
}
log_session_start() {
    local session_type="${1:-work}"
    local duration="${2:-$DEFAULT_DURATION}"
    local session_name="${3:-}"
    local date=$(get_date)
    local time=$(get_time)
    local timestamp=$(get_timestamp)

    echo "  - date: $date" >> "$WORK_LOG"
    echo "    start_time: $time" >> "$WORK_LOG"
    echo "    start_timestamp: $timestamp" >> "$WORK_LOG"
    echo "    type: $session_type" >> "$WORK_LOG"
    echo "    planned_minutes: $duration" >> "$WORK_LOG"
    if [ -n "$session_name" ]; then
        echo "    name: $session_name" >> "$WORK_LOG"
    fi
    echo "    status: in_progress" >> "$WORK_LOG"
    echo "" >> "$WORK_LOG"

    # Force immediate tmux status refresh for session creation
    if [ -n "$TMUX" ]; then
        sleep 0.1  # Brief pause to ensure file write is complete
        tmux refresh-client -S >/dev/null 2>&1
        tmux refresh-client >/dev/null 2>&1  # Double refresh for immediate update
    fi
}

log_session_complete() {
    local end_time=$(get_time)
    local end_timestamp=$(get_timestamp)

    local session_name=""
    local start_timestamp=""
    local actual_duration_formatted=""
    if [ -f "$WORK_LOG" ]; then
        session_name=$(grep -A 10 "status: in_progress\|status: paused" "$WORK_LOG" | grep "name:" | tail -1 | sed 's/.*name: //' || echo "")
        start_timestamp=$(grep -A 10 "status: in_progress\|status: paused" "$WORK_LOG" | grep "start_timestamp:" | tail -1 | sed 's/.*start_timestamp: //' || echo "")
        if [ -n "$start_timestamp" ]; then
            local duration_seconds=$(calculate_session_duration "$start_timestamp" "$end_timestamp")
            actual_duration_formatted=$(format_duration "$duration_seconds")
        fi

        sed -i.bak '
            /status: in_progress/ {
                s/status: in_progress/status: completed/
                a\
    end_time: '"$end_time"'\
    end_timestamp: '"$end_timestamp"'
            }
            /status: paused/ {
                s/status: paused/status: completed/
                a\
    end_time: '"$end_time"'\
    end_timestamp: '"$end_timestamp"'
            }
            /pause_time:/d
            /pause_timestamp:/d
        ' "$WORK_LOG"
        rm -f "$WORK_LOG.bak" 2>/dev/null
    fi

    if [ -n "$actual_duration_formatted" ]; then
        if [ -n "$session_name" ]; then
            send_notification "WISP Session Complete" "Completed $actual_duration_formatted session: $session_name"
        else
            send_notification "WISP Session Complete" "Completed $actual_duration_formatted work session"
        fi
    fi

    if [ -n "$TMUX" ]; then
        tmux refresh-client -S >/dev/null 2>&1
    fi
}

log_session_cancel() {
    if [ -f "$WORK_LOG" ]; then
        sed -i.bak 's/status: in_progress/status: cancelled/' "$WORK_LOG"
        rm -f "$WORK_LOG.bak" 2>/dev/null
    fi
}

log_session_pause() {
    local pause_time=$(get_time)
    local pause_timestamp=$(get_timestamp)

    if [ -f "$WORK_LOG" ]; then
        sed -i.bak '/pause_time:/d; /pause_timestamp:/d' "$WORK_LOG"
        sed -i.bak '/status: in_progress/,$ {
            s/status: in_progress/status: paused/
            /status: paused/ a\
    pause_time: '"$pause_time"'\
    pause_timestamp: '"$pause_timestamp"'
        }' "$WORK_LOG"
        rm -f "$WORK_LOG.bak" 2>/dev/null
    fi

    if [ -n "$TMUX" ]; then
        tmux refresh-client -S >/dev/null 2>&1
    fi
}

log_session_resume() {
    if [ -f "$WORK_LOG" ]; then
        sed -i.bak '/pause_time:/d; /pause_timestamp:/d; s/status: paused/status: in_progress/' "$WORK_LOG"
        rm -f "$WORK_LOG.bak" 2>/dev/null
    fi

    if [ -n "$TMUX" ]; then
        tmux refresh-client -S >/dev/null 2>&1
    fi
}

get_active_session_name() {
    if [ ! -f "$WORK_LOG" ]; then
        return 1
    fi

    awk '
    BEGIN { in_active = 0; session_name = "" }
    /^  - date:/ { in_active = 0; session_name = "" }
    /^    status: (in_progress|paused)/ { in_active = 1 }
    in_active && /^    name:/ {
        gsub(/^    name: /, "", $0)
        session_name = $0
    }
    END {
        if (session_name != "") print session_name
    }
    ' "$WORK_LOG"
}

name_active_session() {
    local session_name="$1"

    if [ ! -f "$WORK_LOG" ]; then
        echo "No work log found."
        return 1
    fi

    if ! (grep -q "status: in_progress" "$WORK_LOG" 2>/dev/null || grep -q "status: paused" "$WORK_LOG" 2>/dev/null); then
        echo "No active session to name."
        return 1
    fi

    if [ -z "$session_name" ]; then
        echo "Please provide a session name."
        return 1
    fi

    # Use a simpler approach: process the file with awk for better control
    awk -v new_name="$session_name" '
    BEGIN {
        in_active = 0
        session_modified = 0
    }

    # Start of a new session
    /^  - date:/ {
        in_active = 0
        session_modified = 0
        print
        next
    }

    # Found active session status
    /^    status: (in_progress|paused)/ {
        in_active = 1
        print
        next
    }

    # Skip existing name lines in active session (we will add our own)
    in_active && /^    name:/ {
        if (!session_modified) {
            print "    name: " new_name
            session_modified = 1
        }
        next
    }

    # Add name after status if we reach end of session block without finding name
    /^$/ && in_active && !session_modified {
        print "    name: " new_name
        session_modified = 1
        print
        next
    }

    # Print all other lines
    { print }

    # Handle end of file case
    END {
        if (in_active && !session_modified) {
            print "    name: " new_name
        }
    }
    ' "$WORK_LOG" > "$WORK_LOG.tmp" && mv "$WORK_LOG.tmp" "$WORK_LOG"
    rm -f "$WORK_LOG.bak" 2>/dev/null

    echo "Session named: $session_name"

    # Force immediate tmux status refresh for session naming
    if [ -n "$TMUX" ]; then
        sleep 0.1  # Brief pause to ensure file write is complete
        tmux refresh-client -S >/dev/null 2>&1
        tmux refresh-client >/dev/null 2>&1  # Double refresh for immediate update
    fi
}

calculate_session_duration() {
    local start_ts="$1"
    local end_ts="$2"

    if [ -n "$start_ts" ] && [ -n "$end_ts" ]; then
        echo $((end_ts - start_ts))
    else
        echo 0
    fi
}

calculate_daily_total() {
    local target_date="$1"
    local total_seconds=0
    local in_session=false
    local start_ts=""
    local end_ts=""
    local session_status=""

    while IFS= read -r line; do
        if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*date:[[:space:]]*(.+) ]]; then
            if [ "$in_session" = true ] && [ "$session_status" = "completed" ] && [ -n "$start_ts" ] && [ -n "$end_ts" ]; then
                local duration=$(calculate_session_duration "$start_ts" "$end_ts")
                total_seconds=$((total_seconds + duration))
            fi

            local session_date="${BASH_REMATCH[1]}"
            if [ "$session_date" = "$target_date" ]; then
                in_session=true
                start_ts=""
                end_ts=""
                session_status=""
            else
                in_session=false
            fi
        elif [ "$in_session" = true ]; then
            if [[ "$line" =~ ^[[:space:]]*start_timestamp:[[:space:]]*([0-9]+) ]]; then
                start_ts="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^[[:space:]]*end_timestamp:[[:space:]]*([0-9]+) ]]; then
                end_ts="${BASH_REMATCH[1]}"
            elif [[ "$line" =~ ^[[:space:]]*status:[[:space:]]*(.+) ]]; then
                session_status="${BASH_REMATCH[1]}"
            fi
        fi
    done < "$WORK_LOG"

    if [ "$in_session" = true ] && [ "$session_status" = "completed" ] && [ -n "$start_ts" ] && [ -n "$end_ts" ]; then
        local duration=$(calculate_session_duration "$start_ts" "$end_ts")
        total_seconds=$((total_seconds + duration))
    fi

    echo $total_seconds
}

format_duration() {
    local seconds="$1"
    local hours=$((seconds / 3600))
    local minutes=$(((seconds % 3600) / 60))
    local secs=$((seconds % 60))

    if [ $hours -gt 0 ]; then
        printf "%dh %02dm %02ds" "$hours" "$minutes" "$secs"
    elif [ $minutes -gt 0 ]; then
        printf "%dm %02ds" "$minutes" "$secs"
    else
        printf "%ds" "$secs"
    fi
}

show_grouped_log() {
    echo "=== Work Session History ==="
    echo

    local current_date=""
    local session_count=0
    local day_sessions=()
    local all_dates=()

    while IFS= read -r line; do
        if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*date:[[:space:]]*(.+) ]]; then
            local date="${BASH_REMATCH[1]}"
            if [[ ! " ${all_dates[@]} " =~ " ${date} " ]]; then
                all_dates+=("$date")
            fi
        fi
    done < "$WORK_LOG"

    IFS=$'\n' all_dates=($(sort -r <<< "${all_dates[*]}"))

    for date in "${all_dates[@]}"; do
        echo "📅 $date"

        local in_session=false
        local start_time=""
        local end_time=""
        local session_type=""
        local planned_minutes=""
        local session_status=""
        local sessions_for_day=0
        local completed_for_day=0

        while IFS= read -r line; do
            if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*date:[[:space:]]*(.+) ]]; then
                if [ "$in_session" = true ]; then
                    sessions_for_day=$((sessions_for_day + 1))
                    if [ "$session_status" = "completed" ]; then
                        completed_for_day=$((completed_for_day + 1))
                    fi
                    display_session "$start_time" "$end_time" "$session_type" "$planned_minutes" "$session_status" "$session_name"
                fi

                local session_date="${BASH_REMATCH[1]}"
                if [ "$session_date" = "$date" ]; then
                    in_session=true
                    start_time=""
                    end_time=""
                    session_type=""
                    planned_minutes=""
                    session_status=""
                    session_name=""
                else
                    in_session=false
                fi
            elif [ "$in_session" = true ]; then
                if [[ "$line" =~ ^[[:space:]]*start_time:[[:space:]]*(.+) ]]; then
                    start_time="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]*end_time:[[:space:]]*(.+) ]]; then
                    end_time="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]*type:[[:space:]]*(.+) ]]; then
                    session_type="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]*planned_minutes:[[:space:]]*([0-9]+) ]]; then
                    planned_minutes="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]*name:[[:space:]]*(.+) ]]; then
                    session_name="${BASH_REMATCH[1]}"
                elif [[ "$line" =~ ^[[:space:]]*status:[[:space:]]*(.+) ]]; then
                    session_status="${BASH_REMATCH[1]}"
                fi
            fi
        done < "$WORK_LOG"

        # Process the last session if we were in one for this date
        if [ "$in_session" = true ]; then
            sessions_for_day=$((sessions_for_day + 1))
            if [ "$session_status" = "completed" ]; then
                completed_for_day=$((completed_for_day + 1))
            fi
            display_session "$start_time" "$end_time" "$session_type" "$planned_minutes" "$session_status" "$session_name"
        fi

        # Show daily summary
        local daily_total_seconds=$(calculate_daily_total "$date")
        local daily_total_formatted=$(format_duration "$daily_total_seconds")
        echo "   📊 Total: $sessions_for_day sessions, $completed_for_day completed, $daily_total_formatted"
        echo
    done
}

display_session() {
    local start_time="$1"
    local end_time="$2"
    local session_type="$3"
    local planned_minutes="$4"
    local session_status="$5"
    local session_name="$6"

    local status_icon="❓"
    case "$session_status" in
        "completed") status_icon="✅" ;;
        "cancelled") status_icon="❌" ;;
        "in_progress") status_icon="🔄" ;;
        "paused") status_icon="⏸️" ;;
    esac

    local time_range="$start_time"
    if [ -n "$end_time" ]; then
        time_range="$start_time → $end_time"
    fi

    local session_display="${planned_minutes}min ${session_type}"
    if [ -n "$session_name" ]; then
        session_display="$session_display - $session_name"
    fi

    echo "   $status_icon $time_range ($session_display)"
}

show_stats() {
    if [ ! -f "$WORK_LOG" ]; then
        echo "No work log found. Start a session first!"
        return 1
    fi

    echo "=== Work Session Statistics ==="
    echo

    local total=$(grep -c "date:" "$WORK_LOG" 2>/dev/null)
    local completed=$(grep -c "status: completed" "$WORK_LOG" 2>/dev/null)
    local cancelled=$(grep -c "status: cancelled" "$WORK_LOG" 2>/dev/null)
    local in_progress=$(grep -c "status: in_progress" "$WORK_LOG" 2>/dev/null)
    local paused=$(grep -c "status: paused" "$WORK_LOG" 2>/dev/null)

    total=${total:-0}
    completed=${completed:-0}
    cancelled=${cancelled:-0}
    in_progress=${in_progress:-0}
    paused=${paused:-0}

    echo "Total sessions: $total"
    echo "Completed: $completed"
    echo "Cancelled: $cancelled"
    echo "In progress: $in_progress"
    echo "Paused: $paused"

    local today=$(get_date)
    local today_sessions=$(grep -A 10 "date: $today" "$WORK_LOG" 2>/dev/null | grep -c "status: completed" 2>/dev/null)
    today_sessions=${today_sessions:-0}

    if [ "$today_sessions" -gt 0 ]; then
        local today_total_seconds=$(calculate_daily_total "$today")
        local today_total_formatted=$(format_duration "$today_total_seconds")
        echo
        echo "Today ($today): $today_sessions completed sessions"
        echo "Today's total time: $today_total_formatted"
    fi
}

get_session_name() {
    local placeholder="Session name (press Enter to skip)"
    local prompt="Session > "
    local width="40"
    local result=""

    # Only try gum if we have a proper interactive terminal
    if command -v gum >/dev/null 2>&1 && [ -t 0 ] && [ -t 1 ]; then
        # Try gum first, with proper error handling for tmux environments
        result=$(gum input --no-show-help --placeholder "$placeholder" --prompt "$prompt" --width "$width" 2>/dev/null)
        local exit_code=$?

        # If gum succeeds, return the result
        if [ $exit_code -eq 0 ]; then
            echo "$result"
            return 0
        fi
        # If gum fails, fall through to read fallback
    fi

    # Fallback to standard read for tmux environments or when gum is unavailable
    printf "%s" "$prompt" >&2

    # Use read with proper signal handling for escape detection
    if ! read -r result; then
        # read failed (Ctrl+C, EOF, etc.)
        return 1
    fi

    echo "$result"
}

main() {
    local cmd="$1"
    shift

    init_work_log

    case "$cmd" in
        "start")
            if [ -f "$WORK_LOG" ] && (grep -q "status: in_progress" "$WORK_LOG" 2>/dev/null || grep -q "status: paused" "$WORK_LOG" 2>/dev/null); then
                log_session_complete
            fi
            local duration="$DEFAULT_DURATION"
            if [ -n "$1" ] && [[ "$1" =~ ^[0-9]+$ ]]; then
                duration="$1"
                shift
            fi

            local session_name=""
            if [ -n "$1" ]; then
                session_name="$*"
            else
                if ! session_name=$(get_session_name); then
                    echo "❌ Cancelled"
                    return 1
                fi
            fi

            log_session_start "work" "$duration" "$session_name"
            if [ -n "$session_name" ]; then
                echo "Started ${duration}min session: $session_name"
            else
                echo "Started ${duration}min session"
            fi
            ;;
        "stop")
            log_session_complete
            ;;
        "pause")
            log_session_pause
            ;;
        "resume")
            log_session_resume
            ;;
        "name")
            name_active_session "$1"
            ;;
        "toggle")
            if [ -f "$WORK_LOG" ] && grep -q "status: in_progress" "$WORK_LOG" 2>/dev/null; then
                log_session_pause
            elif [ -f "$WORK_LOG" ] && grep -q "status: paused" "$WORK_LOG" 2>/dev/null; then
                log_session_resume
            else
                local duration="$DEFAULT_DURATION"
                if [ -n "$1" ] && [[ "$1" =~ ^[0-9]+$ ]]; then
                    duration="$1"
                    shift
                fi

                local session_name=""
                if [ -n "$1" ]; then
                    session_name="$*"
                else
                    if ! session_name=$(get_session_name); then
                        echo "❌ Cancelled"
                        return 1
                    fi
                fi

                log_session_start "work" "$duration" "$session_name"
                if [ -n "$session_name" ]; then
                    echo "Started ${duration}min session: $session_name"
                else
                    echo "Started ${duration}min session"
                fi
            fi
            ;;
        "stats"|"status"|"summary")
            show_stats
            ;;
        "log"|"history"|"show")
            if [ -f "$WORK_LOG" ]; then
                show_grouped_log
            else
                echo "No work log found."
            fi
            ;;
        "today")
            if [ -f "$WORK_LOG" ]; then
                local today=$(get_date)
                echo "=== Today's Sessions ($today) ==="
                grep -A 15 "date: $today" "$WORK_LOG" | head -20
                echo
                local today_total_seconds=$(calculate_daily_total "$today")
                local today_total_formatted=$(format_duration "$today_total_seconds")
                echo "Today's total time: $today_total_formatted"
            else
                echo "No work log found."
            fi
            ;;
        "help"|"-h"|"--help")
            echo "WISP Is a Simple Pomodoro"
            echo
            echo "Usage: $0 [command] [duration]"
            echo
            echo "Commands:"
            echo "  start [mins] [name]  Start new work session (default: 25 min)"
            echo "  toggle [mins] [name] Toggle session (start/pause/resume)"
            echo "  pause                Pause current session"
            echo "  resume               Resume paused session"
            echo "  stop                 Stop current session"
            echo "  name <name>          Name the current active session"
            echo "  stats                Show work statistics"
            echo "  today                Show today's sessions"
            echo "  log                  Show full work history"
            echo "  help                 Show this help"
            echo
            echo "Examples:"
            echo "  wisp start                    # Start 25-minute session (prompts for name)"
            echo "  wisp start 45                 # Start 45-minute session (prompts for name)"
            echo "  wisp start 25 \"Project Work\"  # Start named session directly"
            echo "  wisp name \"Project X\"         # Name current session"
            echo "  wisp stop                     # Stop current session"
            echo
            echo "Work sessions are logged to ~/.wisp.yml"
            echo
            echo "Status formatting:"
            echo "  wisp-format [format] # Get formatted status"
            echo "  Formats: default, tmux, minimal, simple"
            echo "  Custom formats: ~/.config/wisp/formats/"
            echo "  Note: tmux status uses wisp-format tmux"
            ;;
        *)
            echo "Unknown command: $cmd"
            echo "Use 'wisp help' for available commands"
            return 1
            ;;
    esac
}

main "$@"
